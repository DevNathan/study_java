조남호 | Nathan-Cho<br>
06.12.23 ~ 07.04.23

***
## 1. 프로그래밍 언어 용어 정리
### 1-1 프로그래밍 언어란?
    프로그래밍 언어는 개발자와 컴퓨터가 소통하기 위한 언어이며 개발자측에 친화적인 언어이다.

### 1-2 소스코드
    명령어를 작성해 놓은 것
    개발자와 컴퓨터가 소통할 것을 글로 작성해 놓은 것
    
### 1-3 소스파일
    소스코드가 작성되어 있는 파일

### 1-4 컴파일
    사람의 언어를 컴퓨터 언어로 바꿔주는 작업

### 1-5 컴파일러
    컴파일을 해주는 프로그램 또는 명령어

### 1-6 콘솔
    개발자와 컴퓨터가 소통한 결과를 보여주는 창

### 1-7 프로그램과 자바 프로그램
    프로그램 : 소스코드로 잘 짜여진 툴
- 일반 프로그램

      프로그램
      OS(하드웨어에 적절한 전류신호를 보내주는 역할
      하드웨어

      - 일반 프로그램은 이식성이 별로 좋지 못하다.
- JAVA 프로그램

      프로그램
      JVM(JAVA Vertual Machine) : 자바 프로그램을 OS에 맞게 번역
      OS
      하드웨어

      - 이식성이 좋음

***
## 2. JAVA의 구조
    JVM - 자바 프로그램을 실행해줌
    JRE - JVM을 생성하며, 실행할 때 필요한 라이브러리 파일들을 가지고 있다.
    JDK - JRE외에 개발에 필요한 도구들을 가지고 있다. 컴파일 명령어와 실행 명령어를 담고 있다.

### 2-1 기본 구조
    프로젝트
    패키지
    클래스(앞글자 대문자)
    메소드(이름())
    소스코드

    ※ 아래로 내려갈 수록 하위 개념이며 하위 개념은 상위 개념에 속해 있음.

***
# JAVA
## 출력 메소드
    printf() : 줄바꿈이 없어 연속적으로 사용할 경우 이전 문장의 옆에 그대로 붙어서 출력된다.
    println() : 모든 문장 출력후 줄바꿈을 자동으로 해준다.
    printf() : 변수와 관련되어 있으며 글과 같이 출력할때 보통 사용

### 출력 메소드를 사용하는 이유
    전달받은 데이터 및 전달할 데이터를 검사하여 확인 검증이 가능하고
    오류발생시에는 발생 지점을 구체화하고 검사할 수 있다.

***
## 주석
    // 주석이다.
    /* 범위주석이다. 이 안의 내용은 모두 주석 처리 됨. */

***
## 자료형(type)
자료형|Type|Byte|값
---|---|---|---
정수형|int|4|10, 32, -32, 1432, ...
-|long|8|10L, 12L, ...
실수형|float|4|10.5F, -0.9F, 0.0F, 123.4563F, ...
-|double|8|10.5, -0.9, 0.0, 123.4563, ...
문자형|char|2|'김', 'A', '0', ...
문자열|String(class)|문자열의 길이에 따라 다름|"안녕하세요", ...

***
## 램(RAM)의 구조
1. OS Kernel Space
        
        운영체제 커널이 실행되는 영역.
       이 영역은 일반적으로 사용자 프로그램이 접근할 수 없으며,
       커널 모드에서만 읽기와 쓰기가 가능하다.
       이 영역은 운영체제의 기능과 장치 드라이버를 포함한다.

3. Stack

        프로그램의 함수 호출과 지역 변수가 저장되는 영역.
       이 영역은 읽기와 쓰기가 모두 가능하며, 함수가 호출될 때마다 스택 프레임이 생성되고,
       함수가 종료될 때마다 스택 프레임이 제거된다.
       Stack 영역은 메모리의 높은 주소에서 낮은 주소로 감소.

5. Free

        아직 사용되지 않은 메모리 공간으로, 이 영역은 읽기와 쓰기가 모두 가능하며, 프로그램이 필요에 따라 Heap 영역이나 Stack 영역으로 확장할 수 있다.

6. Heap

        프로그램이 동적으로 메모리를 할당하거나 해제할 때 사용하는 영역이다.
       이 영역은 읽기와 쓰기가 모두 가능하며, 프로그램의 요청에 따라 크기가 변할 수 있다.
       Heap 영역은 메모리의 낮은 주소에서 높은 주소로 증가.

8. Bss

        프로그램의 전역 변수와 정적 변수 중에서 초기화되지 않은 값이 저장되는 영역.
       이 영역은 읽기와 쓰기가 모두 가능하며, 실행 시에 0으로 초기화된다.

10. Data

        프로그램의 전역 변수와 정적 변수가 저장되는 영역.
        이 영역은 읽기와 쓰기가 모두 가능하며, 초기화된 값이 있으면 메모리에 로드된다.

12. Text

        프로그램의 코드가 저장되는 영역이다.
        이 영역은 읽기 전용이며, 실행 시에 메모리에 로드된다.

***
## 변수
    변수는 저장공간이다.

### 변수 선언
    Type name = value;
		
    예) Int age = 99;

### 변수 선언(실무적)
	1. 같은 이름의 변수는 선언 될 수 없음
	2. 선언 후 되도록 초기화를 해줄 것.
    3. 되도록 선언부에 한꺼번에 선언한다. (보통 영역 상단에다 몰아서 적는다.)

### 주소(해시코드)
    int x = 10;
    위와 같이 선언되면 메모리에 저장되며 그 저장된 곳의 주소값이 부여되게 된다.
    부여된 주소값은 프로그램이 종료되거나 작동과정중 메모리를 해제해주지 않는 한 동일한 값으로 존재하나
    프로그램 매 시작시마다 항상 다른 값이 부여된다.

### 변수의 사용
    Int data = 20; // 선언
	Data = 30; // 선언
	System.out.print(data+9); // 사용
	Data = data + 7; (data += 7) // 선언 / 사용
    Data - 9; // 사용

### 변수 사용 이유
    1. 반복되는 값을 쉽게 관리할 수 있다.
    2. 의미 없는 값을 하나의 정보로 만들기 위해서 사용한다(자료구조).

### 서식문자
    반드시 따옴표 안에서 작성한다.

    %d : decimal(10진수 정수)
    %o : ocatal(8진수 정수)
    %x : hexadecimal(16진수 정수)
    %f : float(실수)
    %c : character(문자)
    %s : string(문자열)

    이들은 보통 printf()에서 쓰이며 변수의 값을 해당 서식문자에 넣음으로서 확인하기 용도이다.

***
## 상수
    항상 변하지 않는 수.
    값을 변경할 수 없도록 한다.

### 상수 선언
    final type name = value;

    예) final double CURCULAR_CONSTANT

    이 때, 상수의 이름은 가능한 대문자로 표기하며 스네이크표기법으로 적는다. (이는 개발자간 약속임)

### 상수 사용 이유
    1. 의미 없는 값에 의미를 부여하기 위해서 사용한다.
    2. 값보다 이름으로 기억하기 쉬운 이름으로 사용하기 위함이다. 예) 원주율
    3. 오타 방지

***
## 형변환
    형변환은 자료형이 같지 않은 두 값이 연산 등을 하게 될때 생기는 문제를 없애고자
    형변환을 통해 일치시키는 것을 말한다.

1. 자동 형변환

		정수 + 정수 = 정수
 		정수 + 실수 = 실수
		3 + 0.0 = 3.0
2. 강제 형변환

		(type)value

   		(double)3

   		결과는 3.0

3. 문자열 형변환
	1) 다른 자료형을 문자열로 전환
		- 문자열과 다른 일반 자료형을 연결하면 결과는 문자열이 된다.
				
	2) 문자열을 다른 자료형으로
		- 일반자료형은 일반 자료형끼리만 형변황이 가능하므로 string의 클래스에 맞는 integer를 가져오며 그 안에 parseInt()를 가져온다. Double의 경우 Double.parseDouble()

***
## 입력
	커서가 깜빡이는 상태. 
	입력하기 전에 출력을 통해 어떤 값을 입력해야할지 사용자에게 알려주어야 한다.

### 입력 클래스
	Scanner sc = new Scanner(System.in)
### 입력 메소드
	next() : 사용자가 입력한 문자열 값
		- 사용자가 입력한 값 중 공백 또는 개행문자를 구분점으로 각 문자열을 분리한다.
		- 첫 번째 문자열을 첫 번째 next()에 담고
		- 두 번째 문자열은 두 번째 next()에 담는다.
	nextLine() : 사용자가 입력한 문자열 값
		- 공백 또는 줄바꿈 문자도 값으로 취급하므로 그대로 입력 받는다.

***
## 연산자	
	기능이 있는 특수문자

### 연산자 우선순위
	최우선 연산자
	단항 연산자
	산술 연산자
	쉬프트 연산자
	관계 연산자
	논리 연산자
	삼항 연산자
	대입 연산자

 ### 결합성
 	하나의 수식에 동일한 연산자가 여러 번 사용되면
  	알맞은 방향으로 결합되어 연산되는 성질

***
## 논리형(boolean)
	참 : true
 	거짓 : false

   	boolean 변수명 = 값(true, false0

     	논리형은 0과 1로 분리가 가능하므로 항상 1바이트 값으로 저장이 된다.

#### 조건식
	결과가 참 또는 거짓, 둘 중 하나 

- 관계 연산자

		== (같다)
		!= (같지 않다)
		>, < (초과, 미만)
		>=, <= (이상, 이하)

- 논리 연산자
  
		&&  (두 조건식 모두 참이면 참)
		|| (두 조건식 하나만 참이여도 참)
- 단항 연산자

		!, !A, NOT (조건식이 참이면 거짓으로, 거짓이면 참으로 변경)

***
## 삼항 연산자(? :)
	조건식 ? 참 : 거짓
	Int result = 10 > 9 ? 10 : 9;
	단 참과 거짓 자리에는 값만 작성 할 수 있다.
	값으로 봐야함.
		
	단 조건식이 딱 한 개 있을 때에만 사용하는 것이 좋다(코드 가독성이 안좋아짐).

***
## 제어문
### 조건문
1. If와 else

		Else는 if가 true 일 경우 실행하지 않음		
2. Switch문

		switch (){
			Case (): break;
			Default;
		}

### 반복문
1. for 문

		for(초기식; 조건식; 증감식){
			실행 내용
   		}
2. while 문

		
3. do-while 문

		do {
			실행할 문장;
		} while(조건식);

   		적어도 한번은 실행해야 할때.

***
## 배열 : 저장공간의 나열
	1. 변수를 여러 개 선언하는 걸 피하기 위해서 배열을 선언함. 
 	저장 공간을 관리하기가 불편해지기 때문.
  	2. 규칙성 없는 값에 규칙성을 부여하기 위해

### 배열의 선언
	1. 자료형[] 배열명 = { - }; // 어떤 값을 넣을 지 알 때 사용
	2. 자료형[] 배열명 = new 자료형[칸수]; // 어떤 값을 넣을 지는 모르나, 몇 칸 만들지는 알 때 사용
	3. 자료형[] 배열명 = null; // 어떤 값을 넣을 지도 모르고, 몇 칸 만들지도 모를 때 사용
		… 
	배열명 = new 자료형[칸수];

 	• New : heap 메모리에 할당, 초기값을 자동으로 초기화
	• Null : 주소의 초기값, 어떤 주소를 넣을 지 모를 때 작성하는 값
	• 정적 배열과 동적 배열
	 : 자바는 어떤 것이든 heap 메모리에 저장되므로 메모리 상으로는 동적 배열만 존재한다.

### length
	배열명.length

 	배열 선언 후 그 배열의 크기를 나타내고 싶다면 점연산자를 통해 length를 쓰면
  	배열의 길이를 나타내준다.

### 배열의 사용
	Int[] arData = new int[5]; // 선언
	arData[0] = 10; // 선언
	arData[1] + 9; // 사용
	System.out.println(arData[1]); // 사용
	arData[2] = arData[0] + arData[1]; // 선언 / 사용
	System.out.println(arData[5]); // 오류

***
## 2차원 배열 : 배열 안에 배열
	- 1차원 배열을 여러 개 선언할 때 관리하기 힘들기 때문에 2차원 배열을 선언한다.
 	- 다만 메모리 낭비가 심하므로 선호하지 않는다.

### 2차원 배열 선언
	1. 자료형[][] 배열명 = {{1, 2, 3}, {4, 5, 6}};
	2. 자료형[][] 배열명 = new 자료형[][];
	3. 자료형[][] 배열명 = null;
	  배열명 = new 자료형[][];

   	- arrData[2][3]
	- arrData.length : 2
	- arrData[0].length : 3

 	2차원 배열은 'arrData[행][열]'과 같은 구조를 가지고 있다. 
  	그러므로 2차원 배열은 무조건 행부터 접근하여 생각하라

***
##  메소드
	이름 뒤에 소괄호가 붙어 있는 형태.
 	단, 키워드 뒤에 소괄호는 메소드가 아니다.

### 메소드 선언
	리턴타입 메소드명(자료형 매개변수명, …) {
		실행할 문장;
		Return 리턴값;
	}
```java
예시)
int add(int a, int b) {
	return a + b
}
```

	- 리턴 타입 : 리턴값의 타입을 작성한다, 리턴 값이 없을 경우 void를 작성한다.
	- 메소드명 : 동사로 작성한다.
	- 매개변수명 : 외부에서 전달받을 값이 있다면, 자료형과 순서에 맞게 선언해준다.
	- 실행할 문장 : 생략이 가능하다. 메소드의 기능을 구현하는 로직을 작성한다.
	- 리턴값 : 생략 가능, 리턴 값이 있다면 사용한 부분 통채로를 리턴 값으로 봐야 한다.

### 메소드 선언 순서
1. 메소드 이름을 생각한다.
2. 매개변수를 생각한다.
3. 실행항 문장을 작성한다.
4. 리턴값을 작성한다.
5. 리턴타입을 작성한다.	

### 메소드 주의 사항
	메소드를 '선언'할 때에는 {}가 있으며, 반드시 밖에서 선언한다.
 	메소드를 '사용'할 때에는 {}가 없으며, 반드시 메소드 안에서 사용한다.
```java
선언 예)
int add(int a, int b) {
	return a + b
}

사용 예)
void test() {
	System.out.println(add(10, 15));
}
```

### 메소드 사용
	메소드의 리턴 타입이 void 라면 실행 메소드이므로 값으로 봐서는 안된다.
 	메소드의 리턴 타입이 void가 아니라면 사용한 부분 통채로가 리턴값이다.

### 메소드 사용 목적
	1. 코드를 한번 선언함으로서 재사용할 수 있다.
 	(다만, 메소드에 특정성을 부여하는 순간 재사용은 불가능해지므로 목적에만 충실한 메소드를 만들 것)
  	2. 소스코드를 간결화 시킬 수 있다(가독성 향상).

### 리턴
- 리턴해야 할 때
	사용한 쪽에 로직의 결과를 전달해야 할 때.
- 리턴하면 안될 때
  	사용한 쪽에 로직의 결과를 전달할 필요가 없을 때.

***
## 클래스
	공통요소를 한 번만 선언해놓고 가져다 사용만 하도록 설계한다.

	1. 타입이다.
		클래스 안에 선언된 변수와 메소드를 사용하고 싶다면,
		해당 클래스 타입으로 객체를 선언해야 한다.

	2. 주어이다.
		원숭이가 먹는다 바나나를.
		Monkey.eat("바나나");

### 클래스 선언
	Class 클래스명 {
		필드(변수, 메소드)
	}

### 클래스 필드 사용
1. 객체화
	- 객체를 만드는 작업
 	- 추상적인 개념을 구체화 시키는 작업
	- 클래스명 객체명 = new 클래스명();

	객체명.필드명;

		※ .(마침표)
			- 하위 연산자, 멤버변수 접근 연산자, 닷 연산자, 점 연산자
			- 주소값 뒤에서만 사용이 가능하며 해당 주소를 참조하는 명령어이다.

### 생성자
	클래스 이름 뒤에 소괄호가 있는 형태, 메소드와 기능이 똑같지만 메소드라고 부르지 않는다.
	생성자는 리턴이라는 기능이 존재하지 않기 때문이다.(주소 전달 목적)

	1. 해당 클래스의 필드를 메모리에 할당한 후 부여된 주소값을 가져온다.
	2. 초기화

### 기본 생성자
	매개변수가 없는 생성자이며, 클래스 선언 시 자동으로 선언된다.
	사용자가 직접 생성자를 선언하게 되면 기본 생성자는 자동으로 만들어지지 않는다.

### this
	필드에 접근한 객체가 누구인지 알아야 해당 필드에 접근할 수 있다.
	이 때 접근한 객체가 가지고 있는 할당된 필드의 주소값을 this라는 변수에 자동으로 담긴다.

***
## Storage class(저장 기억 부류)
		
-|Stack|Data영역	
---|---|---
-|지역변수, 매개변수|전역변수, 정적변수(static)		
1.초기화 | 직접 | 자동
2.생명주기 | } | new, 프로그램 종료

※ static : 모든 객체가 공유해야 하는 필드에서만 사용한다.

***
## 다형성(polymorphism)
1. 오버로딩(overloading)

		매개변수의 개수 또는 타입이 다르면 동일한 이름의 메소드로 선언할 수 있다.
2. 오버라이딩(overriding) - 재정의

   		부모필드에서 선언한 메소드를 자식 필드에서 수정하고자 할 때 재정의를 해야 한다.
		이 때 재정의를 하게 되면 부모 필드의 메소드는 오버라이딩이 되게 된다.

***
## 상속(Inheritance)
	1. 기존에 선언된 클래스의 필드를 새로 만든 클래스의 필드로 사용하고자 할 때
 	2. 여러 클래스 선언 시 필드가 겹칠 때

### 상속 문법
	Class A {
		A필드
	}
 	
 	Class B extends A {
		B필드
  	}

### Super() : 부모 생성자
	자식 클래스 타입의 객체로 부모필드에 접근할 수 있다.
	하지만 자식 생성자만 호출하기 때문에, 자식 필드만 메모리에 할당된다고 생각할 수 있다.
	사실 자식 생성자는 부모 생성자를 호출하므로 결국 메모리에는 둘 다 할당되게 된다.
 	이 때 부모 생성자를 호출하는 방법은 super()를 사용하는 것이다.
	만약, super()를 작성하지 않더라도 컴파일러가 자동으로 작성해준다.

***
## 접근 권한 제어자
- default

		다른 패키지에서 접근 불가
- public

		모든 곳에서 접근 가능, 해당 파일의 메인 클래스일 경우만 사용 가능
- protected

		다른 패키지에서 접근 불가, 자식은 가능
- private

		다른 클래스에서 접근 불가, 메소드(getter, setter)로만 접근가능
  
***
※ 모든 자식은 부모 타입이다. 자식은 두개의 타입이 있으며 자식은 부모의 타입이기도 하다.

## 캐스팅(Casting)
	1. Up Casting : 자식 값을 부모 타입으로 형변환
 	2. Down Casting : Up casting됟 객체를 자식 타입으로 형변환
  	※ 부모 값을 자식 타입으로 형변환 하는 것은 불가능하다.

    	❗(오버라이딩이 이루어진 후 업캐스팅을 할 시 오버라이딩 된 정보가 업캐스팅 된다.)

### 캐스팅 선언
	1. Up casting / A a = new B();
	2. Down casting / B b = (B)a;

***
## 추상 클래스
	필드 안에 구현이 안된 메소드가 선언되어 있는 클래스를 추상 클래스라고 한다.
 	이 때 구현 되지 않은 메소드를 추상 메소드라고 부른다.
  	반드시 재정의를 통해 구현을 해야지만 메모리에 할당되기 때문에 
   	"강제성"을 부여하기 위해서 추상 메소드로 선언한다.

### 추상 클래스 선언
	abstract class 클래스명 {
		abstract 리턴타입 메소드명(매개변수, …);
		일반 메소드도 선언 가능
	}

***
## 인터페이스
	추상메소드만 만들 수 있고 상수만 사용 가능하다

 	- 추상 클래스를 고도화시킨 문법
  	- 상수와 추상메소드만 존재한다.
   	- 구현은 지정한 클래스에서 진행하고 인터페이스를 다른 클래스에 지정할 때에는
    	implements 키워드를 사용한다.

***
## 추상 클래스와 인터페이스
	추상 클래스와 인터페이스의 다형성을 구현한다는 역할에 있어 비슷한 것처럼 보이나 실제로는 다른 목적을 위해 수행한다.

 - 차이점
	- 추상클래스는 단일 상속만 가능하다. 이는 다중 상속으로 생기는 충돌을 막기 위함이다. 하지만 인터페이스는 다중 상속이 가능하다.
 	- 추상클래스는 변수, 생성자, 일반 메소드, 추상 메소드 선언에 있어 제약이 없으나 인터페이스는 추상 메소드와 상수만 가질 수 있다(자바 8부터는 default와 static 메소드 또한 가능해짐).
  	- 추상클래스는 접근 권한 제어자 사용에 자유로우나 인터페이스는 public과 private(자바 9이상)만 사용이 가능하다.
  
### 추상 클래스와 인터페이스의 혼용
	인터페이스를 사용하여 클래스에 바로 지정하게 될 시 강제성이 생겨 모두 재정의를 통해 구현해야만 한다. 
 	하지만 일반적인 상황에서는 모든 것이 아닌, 필요한 메소드를 골라서 재정의해야한다.
	인터페이스를 직접 지정하지 않고 다른 클래스에 지정한 후 바디를 만들어 놓는다면,
	강제성이 소멸되고 이 클래스를 상속받아서 필드를 구현한다면, 골라서 재정의할 수 있게 된다.
	이 때 중간에서 강제성을 없애주는 클래스를 추상클래스로 선언하기로 하며,
	추상클래스 이름 뒤에는 Adapter를 붙여서 목적을 알려준다.

***
## 마커 인터페이스
	클래스들을 그룹화하기 위한 목적으로 사용한다.
 	인터페이스는 지정한 클래스의 부모이며, 모든 자식은 부모의 타입이므로
  	마커 인터페이스를 지정 받은 클래스들이 하나의 타입으로 묶이게 된다, 이름 뒤에 Marker를 붙여줘야 한다.

	마커 인터페이스의 내부는 아무것도 없이 비어있다. 당연히 아무것도 없기 때문에 어떤 기능을 하는 것은 아니다.
 	다만 이 인터페이스를 구현받음으로서 그 클래스가 마커 인터페이스를 구현받았는지 확인을 통해 클래스를 그룹화 할 수 있다.

***
## 내부 클래스(Inner Class)
- 외부 클래스의 것을 자유롭게 사용 가능(상속과는 다른 개념이다.)
- 외부 클래스가 시행되지 않을시 내부 클래스도 실행되지 않는다(은닉화).
- 어떤 영역 안에 선언되어 있는 클래스는 내부 클래스이다.

### 익명 (내부) 클래스 (Anonymous Inner Class)
	이름이 없는 클래스이며 구현되지 않은 필드를 구현하기 위해 일회성으로 생성되는 클래스이다.
 	익명 클래스는 앞에 있는 생성자의 클래스를 상속 받고 있기에 익명 클래스에 무언사를 추가할지라도
  	업캐스팅만 되므로 의미가 없다.

***
## 함수형 인터페이스(Functional Interface)
	인터페이스 중 추상 메소드를 하나만 가지고 있는 인터페이스를 함수형 인터페이스라고 한다.
 	이 때, @FunctionalInterface를 인터페이스 위에 작성하여 
  	단 하나의 추상 메소드만 선언할 수 있도록 제한해야 한다.

***
## 람다식(Lambda Expression)
	이름이 없는 메소드로서 값처럼 사용이 가능하다. 매개변수로도 전달이 가능하다.
 	함수형 인터페이스는 추상 메소드 한 개만 선언되기 때문에 구현할 때 메소드 이름이 필요 없다.
  	따라서 람다식을 익명 메소드 라고도 부른다.

### 람다식 문법
	1. (매개변수 형식 나열, …) -> 리턴값;
	2. (매개변수 형식 나열, …) -> {2개 이상의 문장 작성; return 리턴값;};
	3. 매개변수가 딱 한 개 있을 경우에만 소괄호 전부 생략 가능

***
## 예외 처리 문법
	컴파일 시, 빌드 시, 런타임 시 오류가 발생하면 이를 제어문으로 막을 수 있으나,
 	제어문으로도 막을 수 없는 오류들을 직접 처리할 수 있어야 한다.

### 예외 처리 문법
	Try {
		예외가 발생 할 수 있는 문장
		예외가 없을 때 실행할 문장
	} catch(예외 이름 객체명){
		예외 발생 시 실행할 문장
	} catch(예외 이름 객체명){
		예외 발생 시 실행할 문장
	}
	… 
	} finally {
		예외 발생 여부에 상관 없이 무조건 실행할 문장
		※ 외부 장치와 연결했을 경우 다시 닫을 때 주로 사용한다.
	}

### 예외 발생
	직접 예외를 발생시키기 위해서는 예외 던지기를 사용해야 하며, 이 때에는 생성자 호출 전 throw 키워드를 사용한다.
	예) throw new BadWordException();

### 사용자 정의 예외
	기본적으로 제공되는 예외가 아닌 특정 상황에서 직접 예외를 만들어야 한다면, Exception 혹은
	RuntimeException을 상속받아서 예외 클래스를 선언해야 한다.
	Exception은 컴파일러가 체크를 하기 때문에 예외처리를 강제로 해야하고,
	RuntimeException은 컴파일러가 체크하지 않기 때문에 예외처리를 선택할 수 있다.

***
## API(Application Programing Interface)
	개발에 필요한 라이브러리들의 집합
 	선배 개발자들이 만들어 놓은 소스코드

  	- 내부 API
		JDK 설치 시 제공해주는 기본 API
		Docs.oracle.com/javase
	- 외부 API
		선배 개발자들이 개발한 패키지 및 클래스들을 의미한다.
		보통 JAR 파일로 배포하며 자바 프로젝트의 build path에 추가하여 사용할 수 있다.

***
## Object 클래스
1. toString()

		- 항상 객체명을 출력할 때에는 toString()을 붙여서 출력해준다. 따라서 객체명만 출력메소드에 전달하더라도 toString() 문자열 값이 출력된다.
		- 기본적으로 Object에서는 소속과 필드 주소를 문자열로 리턴해주지만 실무에선 불필요한 정보이므로 재정의 하여 필드의 정보를 확인하도록 구현할 수 있다.
		- 실무에서는 클래스 선언 시 각 필드의 초기화 여부를 확인하기 위해 toString()을 재정의하여 사용한다.
2. eqauls()

		- 주소값 비교(==)
		- 객체 주소 비교가 아닌 특정 필드를 비교해야 할 경우 재정의한다.
		- 아래있는 해시코드와 함께 같이 초기화 하는 것이 좋다.
3. hashCode()
	
		- JVM에서 관리하는 중복 없는 값. 실제 메모리에 할당되는 주소와 다르다.
		※ 컬렉션 프레임 워크 챕터에서 재정의 목적을 이해하도록 한다.

***
알고리즘

		어떤 문제가 발생되었을 때 해결할 수 있는 절차 혹은 순서
자료구조(저장공간)

		의미 없는 데이터를 하나의 정보로 만들어주는 알고리즘들의 집합
		수집한 자료를 저장하는 방법

## 컬렉션 프레임워크(Collection Framework)
	많은 데이터를 쉽고 효과적으로 관리할 수 있는 표준화된 방법을 제공하는 클래스들의 집합
 1. List extends Collection
	- Vector

			용량관리, 보안성 강화, 처리량 감소 / 사실상 현재에는 사용하지 않음
   	- LinkedList

			FILO(First In Last Out)로 인해 넣을 때는 빨라도 원하는 위치의 데이터를 가져오는 것이 상대적이다.
	- ArrayList

			인덱스로 데이터를 관리한다. 컬렉션 클래스 중 실무에서 가장 많이 사용되는 클래스이며 배열의 인덱스를 이용하여 값을 저장하고 관리한다.

 ※ 배열과 ArrayList의 차이

 		배열은 길이에 제한을 두어야 할 때 자주 사용되고
   		ArrayList는 몇 개의 데이터가 들어올 지 알 수 없을 때 사용한다.

2. Set extends Collection(HashSet)

		- 집합에서는 중복되는 원소를 포함할 수 없는 것 처럼 Hashset이라는 자료구조는 중복되는 값을 무시한다.
		- 저장된 값들은 인덱스가 없기 때문에 순서가 없다.
		- 값의 유무 검사에 특화되어 있는 자료구조이다. 해시코드로 유무 검사가 진행되기 때문에 속도가 상대적으로 좋다.
3. Map
	
		구현 클래스 HashMap(서버 간 데이터 교환) Key와 Value 한 쌍으로 저장되며,
		검색의 목적을 가지고 있다. Key에 중복된 값을 중복된 값을 넣으면
		Value가 최근 값으로 수정되고 중복되지 않은 값을 넣으면 새롭게 추가된다. Value는 중복이 가능하다.

***
## 쓰레드(Thread)
1. 단일 쓰레드
	- 처리경로 한 개만 가지고 있기 때문에 직렬적이다.
	- 동시에 많은 양을 처리하기 힘들기 때문에 상대적으로 비효율적이다.
	- 하나의 작업에 문제가 발생하더라도 다른 작업에는 영향을 끼치지 않는다.
	- 안정성이 보장되고 설계 시 멀티 쓰레드에 비해 쉽다.
2. 멀티 쓰레드
	- 하나의 프로세스를 동시에 처리하는 것처럼 보이나 사실은 매우 짧은 단위로 분할해서 차례로 처리한다.
	- 여러 개 처리 경로를 가질 수 있도록 하며, 동시 작업이 가능해진다.
	- 설계하기 매우 어려우며, 하나의 쓰레드에 문제가 생기면 여러 쓰레드에 문제가 생긴다.
JAVA 웹 서버가 대표적인 멀티 쓰레드이다. 멀티 쓰레드로 설계하면 처리량 증가, 효율성 증가, 처리비용 감소의 장점이 있기 때문에 단점을 감수하고 설계하는 편이다.

2. 멀티 쓰레드

		핵심: run() 메소드 재정의

		1. Thread 클래스 상속
		2. Runnable 인터페이스 구현

***
## 동기화(Synchronized)
	하나의 쓰레드가 자원에 접근 중일 때 다른 쓰레드가 동시에 같은 자원을 접근하지 못하게 막는 것. 즉, 자원 공유 문제를 해결할 수 있다. 각 쓰레드를 제어해야 할 때에도 자주 사용된다.

### 동기화 문법
- 블럭: synchronized(mutex) {...}

- 키워드: synchronized 영역 전체에 동기화를 걸어주며, 메소드 리턴 타입 앞에 작성하면 해당 메소드 전체에 동기화가 걸린다.

### Thread 종료 방법
1. 필드에 boolean 타입의 변수를 선언하고 run()안에 있는 반복문에 해당 변수가 true일 경우 break 하도록 설계한다.
2. sleep() 또는 wait(), join() 등의 메소드를 통해 쓰레드 일시정지 상태일 경우 Thread객체.interrupt()를 사용하여 InterruptedException을 발생시킨다. 이 때 일시정지 시킨 메소드 부분의 catch를 통해 예외를 잡아주고 원하는 문장을 작성하면 된다.
3. 쓰레드를 일시정지하는 코드가 없을 경우 Thread.interrupted()의 상태를 확인한다. Thread객체.interrupt() 사용 시 Thread.interrupted()의 상태는 true로 변경된다. 권장하지 않는 방법이다.
4. System.exit(0)를 사용하면 전체 쓰레드 종료(프로세스 종료)

***
## 파일 입출력
	Stream 이라는 연결통로를 통해 원본 데이터가 알맞는 인코딩 방식으로 전송된다.
	byte단위로 입출력되기 때문에 개별처리이며, 상세 연산이 필요하지 않다면 
 	Buffer를 사용한 입출력을 권장한다. Buffer를 사용하면 일괄처리가 가능해진다.
	Stream -> 용량이 큰거
	Buffer -> 용량이 작은거

- writer(출력)

		BufferWriter : 버퍼를 사용한 출력 클래스
		FileWriter : 전달한 경로의 파일을 출력하기 위한 목적으로 열어준다.
		전달한 경로에 파일이 없다면 새롭게 만든 후 열어준다.
		객체화를 하면 파일이 열린다.

- Reader(입력)

		BufferedReader : 버퍼를 사용한 입력 클래스
		FileReader : 전달한 경로의 파일을 입력하기 위한 목적으로 열어준다.
		전달한 경로에 파일이 없다면 FileNotFoundException이 발생한다

- File(파일정보)

		전달한 경로에 있는 파일의 정보를 담는 타입.
		디렉터리 생성, 해당 경로의 전체 파일 목록, 파일 삭제 등
